{"version":3,"file":"useGamepadNavigation-Kc11nJyB.js","sources":["../../src/hooks/useGamepadNavigation.js"],"sourcesContent":["import { useEffect, useState, useCallback, useRef } from 'react';\n\n/**\n * Custom hook for comprehensive gamepad navigation support\n * Provides 2D spatial navigation, scrollable content support, and modal awareness\n * \n * @param {boolean} isEnabled - Whether gamepad navigation is active\n * @returns {Object} Navigation state and utilities\n */\nexport const useGamepadNavigation = (isEnabled = true) => {\n  const [focusedElement, setFocusedElement] = useState(null);\n  const [navigableElements, setNavigableElements] = useState([]);\n  const [isGamepadConnected, setIsGamepadConnected] = useState(false);\n  const [showFocusIndicator, setShowFocusIndicator] = useState(false);\n  const lastNavigationTime = useRef(0);\n  const buttonStates = useRef({});\n  \n  const registerNavigableElements = useCallback(() => {\n    if (!isEnabled) return;\n    \n    // Find all focusable elements with data-gamepad-focusable attribute AND scrollable containers\n    const allElements = Array.from(\n      document.querySelectorAll('[data-gamepad-focusable=\"true\"]:not([disabled]), [data-gamepad-scrollable=\"true\"]')\n    );\n    \n    // Filter out elements that are hidden or behind modals\n    const visibleElements = allElements.filter(element => {\n      // Check if element is visible\n      const rect = element.getBoundingClientRect();\n      if (rect.width === 0 && rect.height === 0) {\n        // For hidden inputs (like auto-ante toggle), check the parent\n        const parent = element.closest('label') || element.closest('[class*=\"toggle\"]') || element.parentElement;\n        if (parent) {\n          const parentRect = parent.getBoundingClientRect();\n          if (parentRect.width === 0 || parentRect.height === 0) return false;\n        } else {\n          return false;\n        }\n      }\n      \n      // Check if element is behind a modal\n      const modals = document.querySelectorAll('[class*=\"modal\"], [class*=\"Modal\"], [role=\"dialog\"], [class*=\"overlay\"]');\n      if (modals.length > 0) {\n        // Filter to only get actual modal containers (not overlays)\n        const modalContainers = Array.from(modals).filter(modal => {\n          const className = modal.className;\n          // Look for actual modal content containers, not just overlays\n          return className.includes('modal') || className.includes('Modal') || modal.getAttribute('role') === 'dialog';\n        });\n        \n        if (modalContainers.length > 0) {\n          // Sort modals by z-index to find the topmost one\n          const sortedModals = modalContainers.sort((a, b) => {\n            let aZIndex = parseInt(window.getComputedStyle(a).zIndex) || 0;\n            let bZIndex = parseInt(window.getComputedStyle(b).zIndex) || 0;\n            \n            // If z-index is auto/0, check the parent overlay\n            if (aZIndex === 0) {\n              const aOverlay = a.parentElement;\n              if (aOverlay && aOverlay.classList.toString().includes('overlay')) {\n                aZIndex = parseInt(window.getComputedStyle(aOverlay).zIndex) || 0;\n              }\n            }\n            \n            if (bZIndex === 0) {\n              const bOverlay = b.parentElement;\n              if (bOverlay && bOverlay.classList.toString().includes('overlay')) {\n                bZIndex = parseInt(window.getComputedStyle(bOverlay).zIndex) || 0;\n              }\n            }\n            \n            return bZIndex - aZIndex; // Highest z-index first\n          });\n          \n          // Only include elements that are inside the topmost modal\n          const topmostModal = sortedModals[0];\n          return topmostModal && topmostModal.contains(element);\n        }\n      }\n      \n      return true;\n    });\n    \n    setNavigableElements(prevElements => {\n      // Only update if the elements actually changed\n      if (prevElements.length !== visibleElements.length || \n          !prevElements.every((el, i) => el === visibleElements[i])) {\n        return visibleElements;\n      }\n      return prevElements;\n    });\n  }, [isEnabled]);\n\n  const navigateDirection = useCallback((direction) => {\n    const now = Date.now();\n    if (now - lastNavigationTime.current < 150) {\n      return; // Debounce navigation calls\n    }\n    lastNavigationTime.current = now;\n    \n    if (!navigableElements.length) return;\n    \n    // Show focus indicator when navigating\n    setShowFocusIndicator(true);\n    \n    // Always check the actual focused element in the DOM first\n    const actualFocusedElement = document.activeElement;\n    let currentElement = focusedElement;\n    \n    // If the actual focused element is navigable and different from our state, sync it\n    if (actualFocusedElement && \n        actualFocusedElement.getAttribute('data-gamepad-focusable') === 'true' &&\n        navigableElements.includes(actualFocusedElement)) {\n      currentElement = actualFocusedElement;\n      setFocusedElement(actualFocusedElement);\n    }\n    \n    const currentIndex = navigableElements.findIndex(el => el === currentElement);\n    \n    // If no element is currently focused or element not found, start with first element\n    if (currentIndex === -1 || !currentElement) {\n      const firstElement = navigableElements[0];\n      setFocusedElement(firstElement);\n      firstElement.focus();\n      return;\n    }\n    \n    // Handle scrollable content before spatial navigation\n    const currentElem = navigableElements[currentIndex];\n    const isScrollable = currentElem?.getAttribute('data-gamepad-scrollable') === 'true';\n    \n    if (isScrollable && (direction === 'up' || direction === 'down')) {\n      const scrollAmount = 50;\n      const isAtTop = currentElem.scrollTop <= 0;\n      const isAtBottom = currentElem.scrollTop >= currentElem.scrollHeight - currentElem.clientHeight;\n      \n      if (direction === 'up' && !isAtTop) {\n        currentElem.scrollTop = Math.max(0, currentElem.scrollTop - scrollAmount);\n        return;\n      }\n      \n      if (direction === 'down' && !isAtBottom) {\n        currentElem.scrollTop = Math.min(\n          currentElem.scrollHeight - currentElem.clientHeight,\n          currentElem.scrollTop + scrollAmount\n        );\n        return;\n      }\n    }\n    \n    let nextElement = null;\n    \n    if (direction === 'up' || direction === 'down') {\n      // Vertical navigation with intelligent spatial detection\n      let currentRect = currentElem?.getBoundingClientRect();\n      if (!currentRect) return;\n      \n      // Handle zero-dimension elements (hidden inputs, toggles)\n      if (currentRect.width === 0 && currentRect.height === 0) {\n        const label = currentElem.closest('label');\n        const container = currentElem.closest('[class*=\"toggle\"]') || currentElem.closest('[class*=\"Toggle\"]');\n        const parent = label || container || currentElem.parentElement;\n        if (parent) {\n          currentRect = parent.getBoundingClientRect();\n        }\n      }\n      \n      const currentCenterX = currentRect.left + currentRect.width / 2;\n      \n      // Get all candidates in the target direction\n      const candidates = navigableElements\n        .map((el, index) => ({ el, index, rect: el.getBoundingClientRect() }))\n        .filter(({ el, rect, index }) => {\n          // Exclude the current element\n          if (index === currentIndex) return false;\n          \n          if (direction === 'up') {\n            return rect.bottom <= currentRect.top + 20; // More generous tolerance for upward navigation\n          } else {\n            return rect.top >= currentRect.bottom - 20; // More generous tolerance for downward navigation\n          }\n        });\n      \n      \n      if (candidates.length > 0) {\n        // Sort candidates by horizontal distance from current element\n        const sortedCandidates = candidates\n          .map(candidate => ({\n            ...candidate,\n            horizontalDistance: Math.abs(candidate.rect.left + candidate.rect.width / 2 - currentCenterX),\n            verticalDistance: direction === 'up' \n              ? currentRect.top - candidate.rect.bottom \n              : candidate.rect.top - currentRect.bottom\n          }))\n          .sort((a, b) => {\n            const horizontalDiff = a.horizontalDistance - b.horizontalDistance;\n            if (Math.abs(horizontalDiff) > 100) {\n              return horizontalDiff;\n            }\n            const verticalDiff = a.verticalDistance - b.verticalDistance;\n            if (Math.abs(verticalDiff) > 10) {\n              return verticalDiff;\n            }\n            return horizontalDiff;\n          });\n        \n        nextElement = sortedCandidates[0].el;\n      } else {\n        // No elements in target direction - find closest element in ANY direction\n        const allOtherElements = navigableElements\n          .filter((el, index) => index !== currentIndex)\n          .map((el, index) => ({ el, rect: el.getBoundingClientRect() }));\n        \n        if (allOtherElements.length > 0) {\n          // Find the element closest to where we want to go\n          const targetY = direction === 'up' ? 0 : window.innerHeight;\n          const closest = allOtherElements.reduce((best, candidate) => {\n            const candidateDistance = Math.abs(candidate.rect.top - targetY);\n            const bestDistance = Math.abs(best.rect.top - targetY);\n            return candidateDistance < bestDistance ? candidate : best;\n          });\n          nextElement = closest.el;\n        } else {\n          // Ultimate fallback - wrap around\n          if (direction === 'up') {\n            nextElement = navigableElements[navigableElements.length - 1];\n          } else {\n            nextElement = navigableElements[0];\n          }\n        }\n      }\n    } else {\n      // Horizontal navigation within rows\n      const currentRect = currentElem?.getBoundingClientRect();\n      if (!currentRect) {\n        if (direction === 'left') {\n          nextElement = currentIndex > 0 ? navigableElements[currentIndex - 1] : navigableElements[navigableElements.length - 1];\n        } else {\n          nextElement = currentIndex < navigableElements.length - 1 ? navigableElements[currentIndex + 1] : navigableElements[0];\n        }\n      } else {\n        const currentCenterY = currentRect.top + currentRect.height / 2;\n        const rowTolerance = Math.max(currentRect.height / 2, 20);\n        \n        const sameRowElements = navigableElements\n          .map((el, index) => ({ el, index, rect: el.getBoundingClientRect() }))\n          .filter(({ rect, index }) => {\n            const candidateCenterY = rect.top + rect.height / 2;\n            return Math.abs(candidateCenterY - currentCenterY) <= rowTolerance;\n          })\n          .sort((a, b) => a.rect.left - b.rect.left);\n        \n        const currentRowIndex = sameRowElements.findIndex(({ el }) => el === currentElem);\n        \n        if (currentRowIndex !== -1 && sameRowElements.length > 1) {\n          if (direction === 'left') {\n            nextElement = currentRowIndex > 0 ? sameRowElements[currentRowIndex - 1].el : null;\n          } else {\n            nextElement = currentRowIndex < sameRowElements.length - 1 ? sameRowElements[currentRowIndex + 1].el : null;\n          }\n        } else {\n          nextElement = null;\n        }\n      }\n    }\n    \n    if (nextElement) {\n      setFocusedElement(nextElement);\n      nextElement.focus();\n    }\n  }, [navigableElements, focusedElement]);\n\n  const activateElement = useCallback(() => {\n    // Check actual DOM focus first, fallback to our tracked element\n    const elementToActivate = document.activeElement?.getAttribute('data-gamepad-focusable') === 'true' \n      ? document.activeElement \n      : focusedElement;\n      \n    if (elementToActivate) {\n      // Show focus indicator when activating\n      setShowFocusIndicator(true);\n      // Simulate click on the focused element\n      elementToActivate.click();\n    }\n  }, [focusedElement]);\n\n  // Handle keyboard input for testing\n  useEffect(() => {\n    if (!isEnabled) return;\n\n    const handleKeyDown = (e) => {\n      // Check if we're in a text input field\n      const isTextInput = document.activeElement && (\n        document.activeElement.tagName === 'INPUT' || \n        document.activeElement.tagName === 'TEXTAREA'\n      );\n\n      // For text inputs, only prevent default for arrow keys (not Enter)\n      // This allows normal form submission with Enter key\n      if (isTextInput && e.key === 'Enter') {\n        // Don't prevent default, don't activate element\n        // Let the form handle the Enter key naturally\n        return;\n      }\n\n      // Prevent default behavior for navigation keys\n      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter', ' '].includes(e.key)) {\n        e.preventDefault();\n      }\n\n      switch (e.key) {\n        case 'ArrowUp':\n          navigateDirection('up');\n          break;\n        case 'ArrowDown':\n          navigateDirection('down');\n          break;\n        case 'ArrowLeft':\n          navigateDirection('left');\n          break;\n        case 'ArrowRight':\n          navigateDirection('right');\n          break;\n        case 'Enter':\n        case ' ': // Space bar\n          activateElement();\n          break;\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [navigateDirection, activateElement, isEnabled]);\n\n  // Handle gamepad detection and input with native Gamepad API\n  useEffect(() => {\n    if (!isEnabled) return;\n\n    let animationFrame;\n\n    const checkGamepads = () => {\n      const gamepads = navigator.getGamepads();\n      let connected = false;\n\n      for (let i = 0; i < gamepads.length; i++) {\n        const gamepad = gamepads[i];\n        if (gamepad && gamepad.connected) {\n          connected = true;\n          \n          // Track button press states to avoid spamming\n          if (!buttonStates.current[i]) {\n            buttonStates.current[i] = {};\n          }\n          \n          const prevStates = buttonStates.current[i];\n          \n          // D-pad buttons (standard mapping: 12=up, 13=down, 14=left, 15=right)\n          const upPressed = gamepad.buttons[12]?.pressed;\n          const downPressed = gamepad.buttons[13]?.pressed;\n          const leftPressed = gamepad.buttons[14]?.pressed;\n          const rightPressed = gamepad.buttons[15]?.pressed;\n          const aPressed = gamepad.buttons[0]?.pressed; // A button\n\n          // Only trigger on button press (not hold)\n          if (upPressed && !prevStates.up) {\n            navigateDirection('up');\n          }\n          if (downPressed && !prevStates.down) {\n            navigateDirection('down');\n          }\n          if (leftPressed && !prevStates.left) {\n            navigateDirection('left');\n          }\n          if (rightPressed && !prevStates.right) {\n            navigateDirection('right');\n          }\n          if (aPressed && !prevStates.a) {\n            activateElement();\n          }\n\n          // Update previous states\n          prevStates.up = upPressed;\n          prevStates.down = downPressed;\n          prevStates.left = leftPressed;\n          prevStates.right = rightPressed;\n          prevStates.a = aPressed;\n\n          // Left analog stick navigation\n          const leftStickX = gamepad.axes[0] || 0;\n          const leftStickY = gamepad.axes[1] || 0;\n          const deadzone = 0.3;\n\n          if (!prevStates.stickMoved && (Math.abs(leftStickX) > deadzone || Math.abs(leftStickY) > deadzone)) {\n            if (Math.abs(leftStickX) > Math.abs(leftStickY)) {\n              if (leftStickX > deadzone) {\n                navigateDirection('right');\n              } else if (leftStickX < -deadzone) {\n                navigateDirection('left');\n              }\n            } else {\n              if (leftStickY > deadzone) {\n                navigateDirection('down');\n              } else if (leftStickY < -deadzone) {\n                navigateDirection('up');\n              }\n            }\n            prevStates.stickMoved = true;\n          } else if (Math.abs(leftStickX) <= deadzone && Math.abs(leftStickY) <= deadzone) {\n            prevStates.stickMoved = false;\n          }\n\n          // Right analog stick page scrolling\n          const rightStickX = gamepad.axes[2] || 0;\n          const rightStickY = gamepad.axes[3] || 0;\n          const scrollDeadzone = 0.2;\n          const scrollSpeed = 8;\n\n          if (Math.abs(rightStickY) > scrollDeadzone) {\n            const scrollAmount = rightStickY * scrollSpeed;\n            window.scrollBy(0, scrollAmount);\n          }\n          \n          if (Math.abs(rightStickX) > scrollDeadzone) {\n            const scrollAmount = rightStickX * scrollSpeed;\n            window.scrollBy(scrollAmount, 0);\n          }\n        }\n      }\n\n      setIsGamepadConnected(connected);\n      animationFrame = requestAnimationFrame(checkGamepads);\n    };\n\n    checkGamepads();\n\n    return () => {\n      if (animationFrame) {\n        cancelAnimationFrame(animationFrame);\n      }\n    };\n  }, [navigateDirection, activateElement, isEnabled]);\n\n  // Hide focus indicator on mouse movement\n  useEffect(() => {\n    if (!isEnabled) return;\n\n    const handleMouseMove = () => {\n      setShowFocusIndicator(false);\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n    return () => document.removeEventListener('mousemove', handleMouseMove);\n  }, [isEnabled]);\n\n  // Add/remove CSS class to body to control focus indicator visibility\n  useEffect(() => {\n    if (showFocusIndicator) {\n      document.body.classList.add('gamepad-navigation-active');\n    } else {\n      document.body.classList.remove('gamepad-navigation-active');\n    }\n\n    // Cleanup on unmount\n    return () => {\n      document.body.classList.remove('gamepad-navigation-active');\n    };\n  }, [showFocusIndicator]);\n\n  // Handle initial focus when elements are available  \n  useEffect(() => {\n    if (navigableElements.length > 0 && !focusedElement) {\n      const firstElement = navigableElements[0];\n      setFocusedElement(firstElement);\n      // Don't focus initially - let autoFocus handle it\n      // firstElement.focus();\n    }\n  }, [navigableElements.length]); // Only depend on length, not the array itself\n  \n  // Sync focus state when elements gain focus outside of gamepad navigation\n  useEffect(() => {\n    if (!isEnabled) return;\n    \n    const handleFocusChange = (e) => {\n      // Check if the focused element is a navigable element\n      const target = e.target;\n      if (target && target.getAttribute('data-gamepad-focusable') === 'true') {\n        // Register elements first to ensure the list is up to date\n        registerNavigableElements();\n        // Small delay to let the registration complete\n        setTimeout(() => {\n          // Find the element in our navigable elements list\n          const currentNavigableElements = Array.from(\n            document.querySelectorAll('[data-gamepad-focusable=\"true\"]:not([disabled]), [data-gamepad-scrollable=\"true\"]')\n          );\n          \n          if (currentNavigableElements.includes(target)) {\n            setFocusedElement(target);\n            // Don't show focus indicator on programmatic focus (like autoFocus)\n            // Only show it when navigating with keyboard/gamepad\n            // setShowFocusIndicator(true);\n          }\n        }, 0);\n      }\n    };\n    \n    // Listen for focus events globally to catch autoFocus and programmatic focus changes\n    document.addEventListener('focus', handleFocusChange, true); // Use capture phase\n    \n    return () => {\n      document.removeEventListener('focus', handleFocusChange, true);\n    };\n  }, [isEnabled, registerNavigableElements]);\n\n  // Re-register elements when DOM changes\n  useEffect(() => {\n    if (!isEnabled) return;\n    \n    const observer = new MutationObserver(registerNavigableElements);\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['data-gamepad-focusable', 'disabled']\n    });\n    \n    // Initial registration\n    registerNavigableElements();\n    \n    return () => observer.disconnect();\n  }, [registerNavigableElements, isEnabled]);\n\n  return {\n    focusedElement,\n    isGamepadConnected,\n    showFocusIndicator,\n    registerNavigableElements\n  };\n};"],"names":["useGamepadNavigation","isEnabled","focusedElement","setFocusedElement","useState","navigableElements","setNavigableElements","isGamepadConnected","setIsGamepadConnected","showFocusIndicator","setShowFocusIndicator","lastNavigationTime","useRef","buttonStates","registerNavigableElements","useCallback","visibleElements","Array","from","document","querySelectorAll","filter","element","rect","getBoundingClientRect","width","height","parent","closest","parentElement","parentRect","modals","length","modalContainers","modal","className","includes","getAttribute","topmostModal","sort","a","b","aZIndex","parseInt","window","getComputedStyle","zIndex","bZIndex","aOverlay","classList","toString","bOverlay","contains","prevElements","every","el","i","navigateDirection","direction","now","Date","current","actualFocusedElement","activeElement","currentElement","currentIndex","findIndex","firstElement","focus","currentElem","scrollAmount","isAtTop","scrollTop","isAtBottom","scrollHeight","clientHeight","Math","max","min","nextElement","currentRect","label","container","currentCenterX","left","candidates","map","index","bottom","top","candidate","horizontalDistance","abs","verticalDistance","horizontalDiff","verticalDiff","allOtherElements","targetY","innerHeight","reduce","best","currentCenterY","rowTolerance","sameRowElements","candidateCenterY","currentRowIndex","activateElement","elementToActivate","_a","click","useEffect","handleKeyDown","e","tagName","key","preventDefault","addEventListener","removeEventListener","animationFrame","checkGamepads","gamepads","navigator","getGamepads","connected","gamepad","prevStates","upPressed","buttons","pressed","downPressed","_b","leftPressed","_c","rightPressed","_d","aPressed","_e","up","down","right","leftStickX","axes","leftStickY","deadzone","stickMoved","rightStickX","rightStickY","scrollDeadzone","scrollSpeed","scrollBy","requestAnimationFrame","cancelAnimationFrame","handleMouseMove","body","add","remove","handleFocusChange","target","setTimeout","observer","MutationObserver","observe","childList","subtree","attributes","attributeFilter","disconnect"],"mappings":"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"}